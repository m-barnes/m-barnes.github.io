<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap Core CSS -->
      <link href="css/bootstrap.css" rel="stylesheet">
    <!-- Custom CSS -->
      <link href="css/custom.css" rel="stylesheet">
    <!--jquery -->
      <script type="text/javascript" src="js/jquery.js"></script>
  </head>
  <body>
    <header>
      <!--back arrow and title with fixed position-->
      <div class="col-md-12 header navbar navbar-default navbar-fixed-top">
          <div class="col-md-10"><a href="javascript:history.back(1)">&#129104;</a>
          <a href="index.html">Frontend Programming</a></div>
          </div>
          <div class="languages">
            <div class="col-md-4 html">&#60;&nbsp;&#8725;&nbsp;&#62;&nbsp;html</div>
            <div class="col-md-4 css">&#123;&nbsp;&nbsp;&#125;&nbsp;css</div>
          </div>
    </header>
    <main class="col-md-12 main">
      <!--back to top button-->
      <div id="top"><a href="#">Back to Top</a></div>
      <!--Jump Menu-->
      <aside class="col-md-4 col-md-push-8 jump">
        <h4>In this lesson</h4>
        <hr />
        <h5>Objectives</h5>
              <ul>
                <li>Objective 1</li>
                <li>Objective 2</li>
                <li>Objective 3</li>
              </ul><hr/>
        <h5>Terms</h5>
              <ul>
                <li><a href="#tags">Tags</a></li>
                <li><a href="#elements">Elements</a></li>
                <li><a href="#attributes">Attributes</a></li>
              </ul><hr/>
        <h5>Concepts</h5>
              <ul>
                <li><a href="#dom">Document Object Model</a></li>
                <li><a href="#html5">HTML5</a></li>
                <li><a href="#blockInline">Block and Inline</a></li>
              </ul>
        </aside>
        <article class="col-md-8 col-md-pull-4 padding2rem">
          <h1>Lesson 6</h1>
          <h2>Oh, the places you'll go</h2>
          <p>Development--and really all of life, in my opinion--is about looking downstream of where you're at right now and trying to put yourself in the best possible position for all possible futures. That's an incredibly clunky way to simply say that you don't know your content's future. You spend your life creating it, nurturing it, and getting it ready for the world, but once you put it out there you have no idea where it's going to end up, do you? Maybe it ends up on a desktop PC in the middle of Alaska across a ratty phone line. Maybe it finds it's way to an Android phone in Russia, piggybacking off the Wifi in the Kremlin. Or maybe to an iPad in the wilds of Australia via local cell tower. Or maybe--far, far into the future--it ends up on a holoscreen on Mars after bouncing off of 87 different satellites.</p>
          <p>My point--albeit belabored--is that you want to make sure that your stuff looks as good to everyone else--no matter where, how, or on what device they're using--as it does to you when you originally created it.</p>
          <p>In the past, this was insanely difficult because we were forced to use these adapted, ad-hoc methods in ways they were never meant to be used in an effort to control content. The results were fine, but as time as passed we've discovered that they are, largely, incapable and inadequate in the face of controlling content in the modern development landscape.</p>
          <p>While controlling content can still be quite difficult, we do have a few new tricks up our sleeves.</p>
          <h2>Like water for content</h2>
          <h3>Responsive Design</h3>
          <p>The dominant approach in modern web design to combat these issues is known as 'responsive design.' Users today have a myriad of choices in how they view web content--different web browsers, different screen sizes with different capabilities, etc. The idea is to build one website and then provide support for that one website across as many devices as possible, meeting the established standard for content, design, and performance to ensure overall usability and user satistfaction.</p>
          <p>To help with this--and because I like tortured analogies--you should think of content like water.</p>
          <p><img src="images/content_like_water.jpg" alt="Image of water filling various containers"/></p>
          <p>Responsive web design is an extension of user interface plasticity, which is the capability of a user interface to withstand the system's physical characteristics (e.g. screen size, orientation, interaction method, etc.) and software capabilities (e.g. browser support, platform, connection method, etc.) while still preserving usability.</p>
          <p>This has long been the standard in other areas of development, right? Think of PC gaming, for instance. Game developers really have no idea what kind of system you're going to be playing their game on. I mean, they have a general idea, but they have no clue as to the specific capabilities of your personal gaming PC, do they? So, they have to find a way to adapt their experience across a wide variety of systems from the incredibly capable (e.g. monster graphics cards on systems with high-end processors and lots of RAM) to those that aren't (e.g. low-end graphics cards on systems with mid-range processors and minimum amounts of RAM). Game developers--by and large--follow the methodology of 'graceful degredation.' The idea being that you develop for the monster system, but as the capabilities of the system lessen, so, too, does the experience. Draw distances are reduced, textures go low-resolution, dynamic shadow and lighting systems are shut down, etc. The game performs to the maximum capability of the system, keeping the core of the game experience (e.g. gameplay, narrative, etc.) in place, but downgrades the fidelity of that game experience to make sure the user experience remains positive.</p>
          <p>In web design and development we take the antithesis approach and develop from the base experience up (i.e. progressive enhancement) for a number of reasons. The biggest one--at least, right now--is the collective shift of web content consumerism to mobile. For you see, mobile is king - mobile traffic accounts for more than half of all traffic on the internet and is growing...a lot...and quickly. Phones--by and large--aren't as capable as other platforms (e.g. smaller screens, less powerful hardware, etc.), so, it makes sense to develop your content with them in mind as they will, most likely, be the ones looking at your stuff.</p>
          <p>To that end, the current methodology is to develop 'mobile first,' which means you build for smaller screens and low capability and then work your way up. Mobile has the most limitations so it forces you to take a good, long, hard look at your content to decide what's important and what's not, right? Sizzle is good, pretty is great, but if the core content is junk, then people aren't going to stick around for the show.</p>
          <p>Once you have that base experience designed, it's easier to translate that--and add additional functionality--to your content for larger and more capable devices.</p>
          <p>Sites designed with responsive web design principles adapt to the environment on which it is being accessed or displayed by adhering to a few key principles:
            <ul>
              <li>fluid grid concept - the page is often divided into sections or 'grids,' each of a determinate size, which allows for ease of manipulation and movement as the display size changes.</li>
              <li>Relative values - The 'grid' and all elements on the page use relative elements like percentages, em / rem, and vh / vw rather than absolute values like pixels or points.</li>
              <li>media queries - allow for automatic--and specific--movement of content based on characteristics of the display device, usually screen size or width of the browser window.</li>
            </ul>
            <p>Theory is great, but the 'how' is why you're here, so, let's get to it. There are a number of things we can do right out of the gate to make our site more responsive. The general idea is to build for flexibility. This website, for instance, doesn't use a whole lot 'responsive-centric' design elements, but if you resize it, you'll see that--while it isn't perfect--it does scale pretty well (the 'back to top' floating link is problematic because of its absolute positioning). I'm using Bootstrap, which is an HTML, CSS, and JavaScript framework (we'll definitely talk about them later), to build a very basic column setup, and then using a number of CSS rules to keep everything as flexible as I can.</p>
            <h4>Images</h4>
            <p>First, I want to address images. Images can--and do--break a site layout fast when that site is resized. Images--by and large--come in a wide variety of sizes and formats, which makes accommodation of them particularly troublesome. As a rule of thumb, we want the maximum size of the image when displayed to be 100% of the <em>actual size of the image</em>. This prevents smaller images from being blown up and pixelated on larger screens. On the other hand, we also don't want our larger images to take over a disproportionate amount of screen real estate and push all other content out, so, we need some way to reign them in a bit.</p>
            <p>The ideal way is to control the container in which that image is displayed. In this case, the <span class="greenText">&lt;img&gt;</span> element itself.</p>
            <p><pre style="margin: 0; line-height: 125%"><span style="color: #007700">img</span> {
   <span style="color: #008800; font-weight: bold">width</span><span style="color: #333333">:</span><span style="color: #6600EE; font-weight: bold">100</span><span style="color: #333333">%</span>;
 }
</pre></p>
            <p>For larger pictures, this works great. The image will always take up 100% of the <span class="greenText">&lt;img&gt;</span> element. The <span class="greenText">&lt;img&gt;</span> element, in turn, is constrained by its parent element, right? In our example below it's the <span class="greenText">&lt;body&gt;</span> element. So, when you resize, the <span class="greenText">&lt;body&gt;</span> element resizes and, so, too, does the <span class="greenText">&lt;img&gt;</span> element. It's not ideal as regardless of whatever size the image is actually displayed, the browser downloads the full size image to do it, increasing load times and data consumption, but it works.</p>
            <p>The image below is 3000 x 1999 pixels, which is considerable. No matter the size displayed on the screen, the browser is still going to download the full 3000 x 1999 pixel image to display it. There are, of course, other--and some would argue better--ways to do this (e.g. different images at different resolutions, dynamically generating thumbnail versions, etc.), but, like I've said, this works and it's ridiculously easy to implement.</p>
            <p><img src="images/dock_landscape.jpeg" alt="image of a small boat dock at sunset"/>
            <figcaption><a href="https://www.pexels.com/photo/seaport-during-daytime-132037/">"Seaport during Daytime"</a> by <a href="https://www.pexels.com/u/pok-rie-33563/">Pok Rie</a> licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0 1.0</a></p>
            <p>This, however, is a bit of a problem for smaller images as you can see. The image below is 128 x 128 pixels. The parent container is considerably wider, which means our donut becomes a gigantic mess.</p>
            <p><img src="images/donut.png" alt="image of a chocolate covered donut"/></p>
            <p>We've applied the CSS rule to <em>all</em> <span class="greenText">&lt;img&gt;</span> elements. The rule is non-discriminatory. Smaller images, as a result, are blown up to meet the 100% requirement, resulting in a large, ugly, pixelated mess.</p>
            <p>To counter this we can do a couple of things, all of which involve CSS. If know we aren't going to have a lot of these particular use cases (i.e. ridiculously small images being 'gigantisized') then we can set an inline style rule for each case. If we want to cover not just our present use cases, but all future use cases, we can create a class rule in our external style sheet like so:</p>
            <p><pre style="margin: 0; line-height: 125%"><span style="color: #007700">img_small</span> {
   <span style="color: #008800; font-weight: bold">width</span><span style="color: #333333">:</span><span style="color: #008800; font-weight: bold">auto</span>;
 }
</pre></p>
            <p>When we apply that rule to our donut, we get this:</p>
            <p><img src="images/donut.png" class="img_small" alt="image of a chocolate covered donut"/></p>
            <p>Our donut retains its original size and all is right with the world again.</p>
            <h4>Relative sizing</h4>
            <p>I mentioned above that relative sizing was a key principle of responsive design, so, without further adieu, let's define what that means and then run through a brief list of examples.</p>
            <p>Pixels, picas, and points (along with some others that don't start with the letter 'p') fall into the category of absolute lengths or sizes. They are a fixed value and elements expressed using these absolute values will appear exactly to the size specified regardless of other considerations or context. By and large you should avoid absolute sizing of any kind when you can. Again, you don't know how your user is going to be viewing your content and, consequently, using absolute values can lead to unintended effects that can break your layout. Additionally, there is an accessibility issue in the context of those with vision impairments. If they cannot effectively or easily resize elements on your site, it is--as far as they are concerned--unusable.</p>
            <p>The more responsive approach is to use elements with relative sizing. Elements that use relative sizing are scaled relative to some other value and will resize too. For instance, most modern browsers will set the default font size at 16px, so, relative sizing units are typically sized relative to that value. If the user decides to override this value and set their font size to 20px, then all elements sized using relative values will scale as well. Your site will resize accordingly, look great, and you didn't have to do a thing.</p>
            <p>There are several different options as far as relative sizing goes and while there are some 'guidelines' as to their use, it really is just a matter of personal preference based on your design intention. I'll mention just a few of the more common ones.</p>
            <p>
              <ul>
                <li>% (percentages) - just like it sounds. An element whose sizing is set to a percentage will take up that percentage of <em>width</em> of the parent element. A <span class="greenText">&lt;div&rt;</span> element with sizing set to 50% will take up exactly half the width of the element in which it is contained. Percentages do not work with height.</li>
                <li>em - relative to the font-size of the element, which means you have to consider inheritance, right? Setting your size to 2em means your sizing will be 2x the size of the current font.</li>
                <li>rem - same thing, but relative to the font-size of the root element.</li>
                <li>vw - relative to 1% of the width of the viewport (the browser window).</li>
                <li>vh - relative to 1% of the height of the viewport (the browser window).</li>
              </ul>
            </p>
            <p>All of the relative size metrics mentioned above have total support in most modern browsers (and most legacy browsers), including Chrome, IE, Edge, Safari, Opera, and Firefox.</p>
            <p>The common consensus--at least this week--among developers is that you should use rem for all your sizing and spacing <em>unless</em> you're using media queries as the use of rems will break layout when the user forces the browser to 'zoom.' Personally, I don't use media queries a whole lot, so, I just slap rems on everything and call it done. Again, your mileage may vary based on your preferences.</p>
            <h4>Media queries</h4>
            <p>Speaking of media queries...</p>
            <p>I keep beating this poor dead horse, but, again, you don't know how others are going to be viewing your content. Media queries are useful for helping to organize and layout content based on different device archetypes (screen vs. print, the width of the browser viewport, mobile vs. desktop, etc.). On larger screens you have some room with which to work and, consequently, you might want to add additional features and/or functionality to your site. Additional features and/or functionality that just don't work on devices with smaller screens. You might also want to have a different design or layout depending on device orientation (e.g. portrait or landscape).  Interactive elements typically don't 'print' all that well, so, it might be a good idea to have a separate print-centric design that excises those elements from the page before it's sent to a printer.</p>
            <p>The @media rule only applies a certain block of CSS properties if a certain condition is true.</p>
            <p><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">@media</span> <span style="color: #007700">only</span> <span style="color: #007700">screen</span> <span style="color: #007700">and</span> <span style="color: #333333">(</span><span style="color: #007700">max-width</span><span style="color: #333333">:</span> <span style="color: #007700">500px</span><span style="color: #333333">)</span> {
    <span style="color: #007700">body</span> {
        <span style="color: #008800; font-weight: bold">background-color</span><span style="color: #333333">:</span> <span style="color: #007020">lightblue</span>;
    }
}
</pre></p>
            <p>This media query only applies if the content is viewed on a digital screen with a max-width of 500px. If the screen (browser window) is smaller than that, the background will turn a noxious shade of light blue.</p>
            <p>That value of 500px is an example of a 'breakpoint.' It is the fulcrum on which our CSS property pivots, right? If the screen is less than 500px, the background is light blue. If it's larger than 500px, the background is the default color (usually white).</p>
            <p>Breakpoints are often used in reference to screen sizes (desktop screen sizes vs. mobile screen sizes) where content is shifted around and displayed differently according to minimum/maximum window width, but it can refer to any point, or requirement, in the design where the layout or overall functionality is altered from the original design prototype (light themes vs. dark themes, javascript or no javascript, etc.).</p>
            <h4>Viewport</h4>
            <p>The viewport refers the user's visible area of a webpage and it varies according to device.</p>
            <p>If you've ever seen anything like this....</p>
            <p><img src="images/viewport.jpg" alt="image one screen on two devices with different viewport rules"/>
            <figcaption><a href="https://www.flickr.com/photos/myassignmenthelp/17541746243">"Mobile Optimized Website View"</a> by <a href="https://www.flickr.com/photos/myassignmenthelp//">Emma Welth</a> licensed under <a href="https://creativecommons.org/licenses/by/2.0/">CC by 2.0</a></p>
            <p>This is how a site without a viewport attribute looks. The content will scale down ridiculously tiny for small screens in order to accommodate layout. When you visit a site on a mobile device, the site assumes you are visiting it from a desktop and want the full experience. The site then sets the viewport width to a default value (usually somewhere in the neighborhood of 980px depending on the browser). On a mobile device there simply isn't that kind of room and, subsequently, the site gets smooshed and shoved into the smaller screen. </p>
            <p><pre style="margin: 0; line-height: 125%"><span style="color: #333333">&lt;</span><span style="color: #007700">meta</span> <span style="color: #007700">name</span><span style="color: #333333">=</span><span style="background-color: #fff0f0">&quot;viewport&quot;</span> <span style="color: #007700">content</span><span style="color: #333333">=</span><span style="background-color: #fff0f0">&quot;width=device-width, initial-scale=1&quot;</span><span style="color: #333333">&gt;</span>
</pre></p>
            <p>With this simple addendum to our <span class="greenText">&lt;head&rt;</span> element, however, we can gracefully adjust the display for smaller screens, for the most part. It establishes a relationship between the actual width of the device window and the assumed width of the browser window. The rule above establishes a 1:1 relationship with the actual device window and the layout width.</p>
            <p>The viewport meta tag is not the standard, by the way. It was originally developed by Apple engineers and--because it worked--was quickly adopted by everyone and their mothers, but recently that has started to change. W3C never put forth the viewport meta tag standard, which Microsoft was quick to point out when they dropped support in IE10 in certain instances. To that end, you'll probably see developers leaning more on the CSS Device Adaptation standard, which is supported by the W3C. It looks like this:</p>
            <p><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">@viewport</span>{
    <span style="color: #007700">zoom</span><span style="color: #333333">:</span> <span style="color: #007700">1</span><span style="color: #BB0066; font-weight: bold">.0</span><span style="color: #333333">;</span>
    <span style="color: #007700">width</span><span style="color: #333333">:</span> <span style="color: #007700">device-width</span><span style="color: #333333">;</span>
}
</pre></p>
            <p>This removes the responsiblity of 'styling' the page from HTML and shifts it back to our CSS as is the way it should be, all things considered.</p>






            <h3>Flexbox</h3>

            <h3>CSS grids</h3>

            <h3>Frameworks</h3>




  			</article>
      </main>
      <script>
        (function($) {
        $(document).ready(function(){

            //When distance from top = 250px fade button in/out
            $(window).scroll(function(){
                if ($(this).scrollTop() > 250) {
                    $('#top').fadeIn(300);
                } else {
                    $('#top').fadeOut(300);
                }
            });
        });
        })(jQuery);
      </script>
  </body>
</html>
